<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 3 | Notes</title>
  <meta name="author" content="Shichao Yuan">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Notes"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Notes</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Notes</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Stay Hungry, Stay Foolish.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-11-05 </div>
			<div class="article-title"><a href="/2013/11/05/notes_eyawtkasbwata/" >Reading notes: Everything You Always Wanted to Know About Synchronization but Were Afraid to Ask</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <p><a href="http://sigops.org/sosp/sosp13/papers/p33-david.pdf" target="_blank" rel="external">Everything You Always Wanted to Know About Synchronization but Were Afraid to Ask</a>，SOSP’13上的一篇文章，如果对concurrent感兴趣，那么推荐读一下。</p>
<p>扩展软件系统到多核很难很重要，关键在于synchronization。</p>
<blockquote>
<p>From the Greek “syn”, i.e., <em>with</em>, and “khronos”, i.e., <em>time</em>, synchronization denotes the act of coordinating the timeline of a set of processes. (供扯淡使用)</p>
</blockquote>
<p>也就是说，设计一个synchronization scheme，随着核数的增加，性能不下降。但是由于软件层面的同步与硬件层面的同步是相互独立的，所以很难提出普适性的设计，很难评估新的研究成果。总的来说同步的可扩展性主要在于硬件层面。</p>
<blockquote>
<p>Results of this study can be used to help predict the cost of a synchronization scheme, explain its behavior, design better schemes, as well as possibly improve future hardware design.</p>
</blockquote>
<p>本文有几个重要的结论：</p>
<ol style="list-style-type: decimal">
<li><p>crossing sockets significantly impacts synchronization, regardless of the layer, e.g., cache coherence, atomic operations, locks. Message passing can be viewed as a way to reduce sharing as it enforces partitioning of the shared data. However, it comes at the cost of lower performance (than locks) on a few cores or low contention.</p></li>
<li><p>non-uniformity affects scalability even within a single-socket many-core, i.e., synchronization on a Sun Niagara 2 scales better than on a Tilera TILE-Gx36.</p></li>
<li><p>spin locks should be preferred over more complex locks. Complex locks have a lower uncontested performance, a larger memory footprint, and only outperform spin locks under relatively high contention.</p></li>
<li><p>implementing multi-socket coherence using broadcast or an incomplete directory (as on the Opteron) is not favorable to synchronization.</p></li>
</ol>
<p>另外本文还贡献了一个跨平台的同步工具包<a href="http://lpd.epfl.ch/site/ssync" target="_blank" rel="external">SSYNC</a>。</p>
 -->
	
	</div>
  <a type="button" href="/2013/11/05/notes_eyawtkasbwata/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-09-19 </div>
			<div class="article-title"><a href="/2013/09/19/java_object_in_memory/" >Java Object in Memory</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <p>在一些高性能的Java代码中，经常会看到padding，其作用是避免false sharing。</p>
<p>例如Disruptor中的Sequencer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Sequence&#10;&#123;&#10;    static final long INITIAL_VALUE = -1L;&#10;    private static final Unsafe UNSAFE;&#10;    private static final long VALUE_OFFSET;&#10;&#10;    static&#10;    &#123;&#10;        UNSAFE = Util.getUnsafe();&#10;        final int base = UNSAFE.arrayBaseOffset(long[].class);&#10;        final int scale = UNSAFE.arrayIndexScale(long[].class);&#10;        VALUE_OFFSET = base + (scale * 7);&#10;    &#125;&#10;&#10;    private final long[] paddedValue = new long[15];&#10;&#9;&#10;......</span><br></pre></td></tr></table></figure>
<p>其中的paddedValue从功能上来说只用到了第8个long值，而为了避免false sharing初始化15个long。</p>
<p>false sharing很容易理解，cache line嘛，通常是64byte或者128byte。这里让笔者困惑的是——为什么是15而不是16？</p>
<p>关于Java Object在内存中结构，笔者在<a href="http://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf" target="_blank" rel="external">JVMS</a>中没有找到详细的解释。而在一篇博客<a href="http://www.codeinstructions.com/2008/12/java-objects-memory-structure.html" target="_blank" rel="external">Java Objects Memory Structure</a>中找到了一些关于HotSpot JVM的相关内容。</p>
<blockquote>
<p>Rule 1: every object is aligned to an 8 bytes granularity.</p>
</blockquote>
<blockquote>
<p>Rule 2: class attributes are ordered like this: first longs and doubles; then ints and floats; then chars and shorts; then bytes and booleans, and last the references. The attributes are aligned to their own granularity.</p>
</blockquote>
<blockquote>
<p>Rule 3: Fields that belong to different classes of the hierarchy are NEVER mixed up together. Fields of the superclass come first, obeying rule 2, followed by the fields of the subclass.</p>
</blockquote>
<blockquote>
<p>Rule 4: Between the last field of the superclass and the first field of the subclass there must be padding to align to a 4 bytes boundary.</p>
</blockquote>
<blockquote>
<p>Rule 5: When the first field of a subclass is a double or long and the superclass doesn’t align to an 8 bytes boundary, JVM will break rule 2 and try to put an int, then shorts, then bytes, and then references at the beginning of the space reserved to the subclass until it fills the gap.</p>
</blockquote>
<p>这些Rules也解决不了笔者的困惑，不过另外几句话提供了一些线索。</p>
<blockquote>
<p>In the Sun JVM, every object (except arrays) has a 2 words header. The first word contains the object’s identity hash code plus some flags like lock state and age, and the second word contains a reference to the object’s class.</p>
</blockquote>
<blockquote>
<p>Arrays have an extra header field that contain the value of the ‘length’ variable. The array elements follow, and the arrays, as any regular objects, are also aligned to an 8 bytes boundary.</p>
</blockquote>
<p>这篇博客的描述基于32bits HotSpot JVM，我们先写个程序验证一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedExceptionAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectsMemoryStructure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span>[] paddedValue = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> PrivilegedExceptionAction&lt;Unsafe&gt; action = <span class="keyword">new</span> PrivilegedExceptionAction&lt;Unsafe&gt;() &#123;</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Unsafe <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					Field theUnsafe = Unsafe.class</span><br><span class="line">							.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">					theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					<span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			UNSAFE = AccessController.doPrivileged(action);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to load unsafe"</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paddedValue.length; i++) &#123;</span><br><span class="line">			paddedValue[i] = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">160</span>; i++) &#123;</span><br><span class="line">			System.out.print(String.format(<span class="string">"%02x "</span>, UNSAFE.getByte(paddedValue, i) &amp; <span class="number">0xFF</span>));</span><br><span class="line">			<span class="keyword">if</span> (((i+<span class="number">1</span>) % <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">				System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		VolatileLong vlong = <span class="keyword">new</span> VolatileLong();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">88</span>; i++) &#123;</span><br><span class="line">			System.out.print(String.format(<span class="string">"%02x "</span>, UNSAFE.getByte(vlong, i) &amp; <span class="number">0xFF</span>));</span><br><span class="line">			<span class="keyword">if</span> (((i+<span class="number">1</span>) % <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">				System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1=<span class="number">1</span>, p2=<span class="number">2</span>, p3=<span class="number">3</span>, p4=<span class="number">4</span>, p5=<span class="number">5</span>, p6=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在32bits HotSpot JVM下执行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\springsource\workspace-sts-3.2.0.RELEASE\test\bin&#62;&#34;C:\Program Files (x86)\Jav&#10;a\jre7\bin\java.exe&#34; ObjectsMemoryStructure&#10;01 00 00 00 a0 46 04 3c&#10;0f 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;02 00 00 00 00 00 00 00&#10;03 00 00 00 00 00 00 00&#10;04 00 00 00 00 00 00 00&#10;05 00 00 00 00 00 00 00&#10;06 00 00 00 00 00 00 00&#10;07 00 00 00 00 00 00 00&#10;08 00 00 00 00 00 00 00&#10;09 00 00 00 00 00 00 00&#10;0a 00 00 00 00 00 00 00&#10;0b 00 00 00 00 00 00 00&#10;0c 00 00 00 00 00 00 00&#10;0d 00 00 00 00 00 00 00&#10;0e 00 00 00 00 00 00 00&#10;0f 00 00 00 00 00 00 00&#10;01 00 00 00 a8 09 a1 3b&#10;a8 b2 09 27 eb fa 7e ef&#10;00 00 00 00 00 00 00 00&#10;&#10;01 00 00 00 70 6e 05 37&#10;00 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;02 00 00 00 00 00 00 00&#10;03 00 00 00 00 00 00 00&#10;04 00 00 00 00 00 00 00&#10;05 00 00 00 00 00 00 00&#10;06 00 00 00 00 00 00 00&#10;01 00 00 00 40 17 05 3c&#10;01 00 00 00 e8 f0 09 27&#10;01 00 00 00 38 d2 03 37</span><br></pre></td></tr></table></figure>
<p>可见上文的描述与实现相符。<code>private final long[] paddedValue = new long[15];</code>在内存中占用了136byte，不是完美的128byte。按照paddedValue的使用方式，无论136还是128没有太大的区别，但是笔者还是有点儿小小的疑问。</p>
<p>在64bits HotSpot JVM下执行输出如下（UseCompressedOops默认是为true）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxynode@proxynode0:~/shichaoyuan$ jdk1.7.0_25/bin/java ObjectsMemoryStructure&#10;01 00 00 00 00 00 00 00&#10;7a 02 e8 e7 0f 00 00 00&#10;01 00 00 00 00 00 00 00&#10;02 00 00 00 00 00 00 00&#10;03 00 00 00 00 00 00 00&#10;04 00 00 00 00 00 00 00&#10;05 00 00 00 00 00 00 00&#10;06 00 00 00 00 00 00 00&#10;07 00 00 00 00 00 00 00&#10;08 00 00 00 00 00 00 00&#10;09 00 00 00 00 00 00 00&#10;0a 00 00 00 00 00 00 00&#10;0b 00 00 00 00 00 00 00&#10;0c 00 00 00 00 00 00 00&#10;0d 00 00 00 00 00 00 00&#10;0e 00 00 00 00 00 00 00&#10;0f 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;d8 16 e8 e7 0b 5e 2f f8&#10;eb fa 7e ef 00 00 00 00&#10;&#10;01 00 00 00 00 00 00 00&#10;cc 3c ed e7 00 00 00 00&#10;00 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;02 00 00 00 00 00 00 00&#10;03 00 00 00 00 00 00 00&#10;04 00 00 00 00 00 00 00&#10;05 00 00 00 00 00 00 00&#10;06 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;5c 56 e9 e7 01 00 00 00</span><br></pre></td></tr></table></figure>
<p>header的格式与长度发生了变化，非arrays的object的header也变成了16byte。</p>
<p>在64bits HotSpot JVM下执行输出如下（将UseCompressedOops设置为false）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxynode@proxynode0:~/shichaoyuan$ jdk1.7.0_25/bin/java -XX:-UseCompressedOops ObjectsMemoryStructure&#10;01 00 00 00 00 00 00 00&#10;d0 13 40 a4 41 7f 00 00&#10;0f 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;02 00 00 00 00 00 00 00&#10;03 00 00 00 00 00 00 00&#10;04 00 00 00 00 00 00 00&#10;05 00 00 00 00 00 00 00&#10;06 00 00 00 00 00 00 00&#10;07 00 00 00 00 00 00 00&#10;08 00 00 00 00 00 00 00&#10;09 00 00 00 00 00 00 00&#10;0a 00 00 00 00 00 00 00&#10;0b 00 00 00 00 00 00 00&#10;0c 00 00 00 00 00 00 00&#10;0d 00 00 00 00 00 00 00&#10;0e 00 00 00 00 00 00 00&#10;0f 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;c8 ba 40 a4 41 7f 00 00&#10;&#10;01 00 00 00 00 00 00 00&#10;38 9c 6a a4 41 7f 00 00&#10;00 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;02 00 00 00 00 00 00 00&#10;03 00 00 00 00 00 00 00&#10;04 00 00 00 00 00 00 00&#10;05 00 00 00 00 00 00 00&#10;06 00 00 00 00 00 00 00&#10;01 00 00 00 00 00 00 00&#10;c0 e9 4a a4 41 7f 00 00</span><br></pre></td></tr></table></figure>
<p>header的格式与长度又发生了变化，arrays的header变成了24byte。</p>
<p>看来这个没有被规范的地方，不同的硬件和平台存在着些许的不同。15或许在某些JVM实现中是完美的，所以笔者也不打算深究这个疑问了。</p>
<p>下面我们来看看header里存储了那些内容。</p>
<p>笔者查看了<a href="http://hg.openjdk.java.net/jdk7u/jdk7u" target="_blank" rel="external">openjdk7u</a>项目中hotspot的源代码，在<code>oop.hpp</code>和<code>markOop.hpp</code>中找到了一些相关的代码和注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> oopDesc &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> VMStructs;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop  _mark;</span><br><span class="line">  <span class="keyword">union</span> _metadata &#123;</span><br><span class="line">    wideKlassOop    _klass;</span><br><span class="line">    narrowOop       _compressed_klass;</span><br><span class="line">  &#125; _metadata;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The markOop describes the header of an object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">Note</span> that the mark is not a real oop but just a word.</span></span><br><span class="line"><span class="comment">// It is placed in the oop hierarchy for historical reasons.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - hash contains the identity hash value: largest value is</span></span><br><span class="line"><span class="comment">//    31 bits, see os::random().  Also, 64-bit vm's require</span></span><br><span class="line"><span class="comment">//    a hash value no bigger than 32 bits because they will not</span></span><br><span class="line"><span class="comment">//    properly generate a mask larger than that: see library_call.cpp</span></span><br><span class="line"><span class="comment">//    and c1_CodePatterns_sparc.cpp.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - the biased lock pattern is used to bias a lock toward a given</span></span><br><span class="line"><span class="comment">//    thread. When this pattern is set in the low three bits, the lock</span></span><br><span class="line"><span class="comment">//    is either biased toward a given thread or "anonymously" biased,</span></span><br><span class="line"><span class="comment">//    indicating that it is possible for it to be biased. When the</span></span><br><span class="line"><span class="comment">//    lock is biased toward a given thread, locking and unlocking can</span></span><br><span class="line"><span class="comment">//    be performed by that thread without using atomic operations.</span></span><br><span class="line"><span class="comment">//    When a lock's bias is revoked, it reverts back to the normal</span></span><br><span class="line"><span class="comment">//    locking scheme described below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    <span class="doctag">Note</span> that we are overloading the meaning of the "unlocked" state</span></span><br><span class="line"><span class="comment">//    of the header. Because we steal a bit from the age we can</span></span><br><span class="line"><span class="comment">//    guarantee that the bias pattern will never be seen for a truly</span></span><br><span class="line"><span class="comment">//    unlocked object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    <span class="doctag">Note</span> also that the biased state contains the age bits normally</span></span><br><span class="line"><span class="comment">//    contained in the object header. Large increases in scavenge</span></span><br><span class="line"><span class="comment">//    times were seen when these bits were absent and an arbitrary age</span></span><br><span class="line"><span class="comment">//    assigned to all biased objects, because they tended to consume a</span></span><br><span class="line"><span class="comment">//    significant fraction of the eden semispaces and were not</span></span><br><span class="line"><span class="comment">//    promoted promptly, causing an increase in the amount of copying</span></span><br><span class="line"><span class="comment">//    performed. The runtime system aligns all JavaThread* pointers to</span></span><br><span class="line"><span class="comment">//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))</span></span><br><span class="line"><span class="comment">//    to make room for the age bits &amp; the epoch bits (used in support of</span></span><br><span class="line"><span class="comment">//    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></span><br><span class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></span><br><span class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></span><br><span class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></span><br><span class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></span><br><span class="line"><span class="comment">//                                               not valid at any other time</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    We assume that stack/thread pointers have the lowest two bits cleared.</span></span><br></pre></td></tr></table></figure>
<p>在32bits的情况下，前32bits包含hash值以及锁信息，后32bit包含指向类的指针。</p>
<p>在64bits的情况下，前32bits包含hash值以及锁信息，后64bit包含指向类的指针，如果没有UseCompressedOops，那么长度为64bit；如果使用了UseCompressedOops，那么长度为32bit。这也就解释了第二个测试中，array的长度仍为16byte的原因，因为表示长度的32bit藏在了压缩后的指针后面。</p>
<p>坦白说，显式使用padding的方式很不优雅，如果能实现在JIT中对Java程序员来说绝对是福音啊。</p>
 -->
	
	</div>
  <a type="button" href="/2013/09/19/java_object_in_memory/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-08-10 </div>
			<div class="article-title"><a href="/2013/08/10/memorybarrier/" >About Memory Barrier</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <h2 id="引言">引言</h2>
<p>什么是Memory Barrier？stackoverflow中有一个经典的<a href="http://stackoverflow.com/questions/286629/what-is-a-memory-fence" target="_blank" rel="external">回答</a>：</p>
<blockquote>
<p>For performance gains modern CPUs often execute instructions out of order to make maximum use of the available silicon (including memory read/writes). Because the hardware enforces instructions integrity you never notice this in a single thread of execution. However for multiple threads or environments with volatile memory (memory mapped I/O for example) this can lead to unpredictable behavior.</p>
</blockquote>
<blockquote>
<p>A memory fence/barrier is a class of instructions that mean memory read/writes occur in the order you expect. For example a ‘full fence’ means all read/writes before the fence are comitted before those after the fence.</p>
</blockquote>
<blockquote>
<p>Note memory fences are a hardware concept. In higher level languages we are used to dealing with mutexes and semaphores - these may well be implemented using memory fences at the low level and explicit use of memory barriers are not necessary. Use of memory barriers requires a careful study of the hardware architecture and more commonly found in device drivers than application code.</p>
</blockquote>
<blockquote>
<p>The CPU reordering is different from compiler optimisations - although the artefacts can be similar. You need to take separate measures to stop the compiler reordering your instructions if that may cause undesirable behaviour (e.g. use of the volatile keyword in C).</p>
</blockquote>
<p>从高级语言编程的角度，理解与掌握Memory Barrier是容易的，但是对于硬件角度的Memory Barrier却有很多疑惑。所有笔者尝试通过本文自上而下将整个story串起来。</p>
<h2 id="幼稚的例子">幼稚的例子</h2>
<p>这个例子的思路来在一个带有cancel功能的GUI程序。（这种方式绝对的幼稚，但是本文的目的不在于cancel功能的实现，所以在下文也不会完善该功能，所做的改动仅仅是为了展示memory barrier）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">while</span> (!cancel) &#123;</span><br><span class="line">                                        i++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                System.out.println(<span class="string">"Done!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"OS: "</span> + System.getProperty(<span class="string">"os.name"</span>) + <span class="string">" "</span> + System.getProperty(<span class="string">"os.arch"</span>) + <span class="string">"\n"</span></span><br><span class="line">                                + <span class="string">"JavaVersion: "</span> + System.getProperty(<span class="string">"java.version"</span>) + <span class="string">"\n"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2048</span>);</span><br><span class="line">                cancel = <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">"flag cancel set to true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者只有一台古老的机器（Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz），执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuan@yuan-HP:~/learn$ jdk1.7.0_25/bin/java MemoryBarrierDemo&#10;OS: Linux amd64&#10;JavaVersion: 1.7.0_25&#10;&#10;flag cancel set to true</span><br></pre></td></tr></table></figure>
<p>程序一直处于循环递增<code>i</code>的状态，没有退出。也就是说程序中启动的子线程“看不到”主线程对共享变量<code>cancel</code>的改动，这就是从高级语言层面所看到的memory barrier，想要让子线程“看到”改变，那么就得让改变“穿过”memory barrier。</p>
<p>如何做？在_Java Concurrency in Practice_的3.1节介绍了两种方法——locking和volatile variable。在此我们试着用volatile关键字，将前面程序中的<code>private static boolean cancel;</code>改为<code>private static volatile boolean cancel;</code>。再次编译执行程序，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuan@yuan-HP:~/learn$ jdk1.7.0_25/bin/java MemoryBarrierDemo&#10;OS: Linux amd64&#10;JavaVersion: 1.7.0_25&#10;&#10;flag cancel set to true&#10;Done!&#10;yuan@yuan-HP:~/learn$</span><br></pre></td></tr></table></figure>
<p>如此程序就可以按照设想的那像正常退出了，很简单吧。</p>
<p>好的，下面就开始探索笔者困惑的部分了。</p>
<h2 id="汇编代码">汇编代码</h2>
<p>下面我们通过添加几个参数打印出反汇编的代码看看。</p>
<p>没有volatile的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuan@yuan-HP:~/learn$ jdk1.7.0_25/bin/java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly MemoryBarrierDemo&#10;Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output&#10;OS: Linux amd64&#10;JavaVersion: 1.7.0_25&#10;&#10;Loaded disassembler from /home/yuan/learn/jdk1.7.0_25/jre/lib/amd64/hsdis-amd64.so&#10;Decoding compiled method 0x00007fbe883df890:&#10;Code:&#10;[Disassembling for mach=&#39;i386:x86-64&#39;]&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;access$000&#39; &#39;()Z&#39; in &#39;MemoryBarrierDemo&#39;&#10;  #           [sp+0x20]  (sp of caller)&#10;  0x00007fbe883df9c0: sub    $0x18,%rsp&#10;  0x00007fbe883df9c7: mov    %rbp,0x10(%rsp)    ;*synchronization entry&#10;                                                ; - MemoryBarrierDemo::access$000@-1 (line 1)&#10;  0x00007fbe883df9cc: mov    $0xebcfc590,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fbe883df9d6: movzbl 0x70(%r10),%eax    ;*getstatic cancel&#10;                                                ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;  0x00007fbe883df9db: add    $0x10,%rsp&#10;  0x00007fbe883df9df: pop    %rbp&#10;  0x00007fbe883df9e0: test   %eax,0x9c6b61a(%rip)        # 0x00007fbe9204b000&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fbe883df9e6: retq&#10;  0x00007fbe883df9e7: hlt&#10;  0x00007fbe883df9e8: hlt&#10;  0x00007fbe883df9e9: hlt&#10;  0x00007fbe883df9ea: hlt&#10;  0x00007fbe883df9eb: hlt&#10;  0x00007fbe883df9ec: hlt&#10;  0x00007fbe883df9ed: hlt&#10;  0x00007fbe883df9ee: hlt&#10;  0x00007fbe883df9ef: hlt&#10;  0x00007fbe883df9f0: hlt&#10;  0x00007fbe883df9f1: hlt&#10;  0x00007fbe883df9f2: hlt&#10;  0x00007fbe883df9f3: hlt&#10;  0x00007fbe883df9f4: hlt&#10;  0x00007fbe883df9f5: hlt&#10;  0x00007fbe883df9f6: hlt&#10;  0x00007fbe883df9f7: hlt&#10;  0x00007fbe883df9f8: hlt&#10;  0x00007fbe883df9f9: hlt&#10;  0x00007fbe883df9fa: hlt&#10;  0x00007fbe883df9fb: hlt&#10;  0x00007fbe883df9fc: hlt&#10;  0x00007fbe883df9fd: hlt&#10;  0x00007fbe883df9fe: hlt&#10;  0x00007fbe883df9ff: hlt&#10;[Exception Handler]&#10;[Stub Code]&#10;  0x00007fbe883dfa00: jmpq   0x00007fbe883dc860  ;   &#123;no_reloc&#125;&#10;[Deopt Handler Code]&#10;  0x00007fbe883dfa05: callq  0x00007fbe883dfa0a&#10;  0x00007fbe883dfa0a: subq   $0x5,(%rsp)&#10;  0x00007fbe883dfa0f: jmpq   0x00007fbe883b6c00  ;   &#123;runtime_call&#125;&#10;  0x00007fbe883dfa14: hlt&#10;  0x00007fbe883dfa15: hlt&#10;  0x00007fbe883dfa16: hlt&#10;  0x00007fbe883dfa17: hlt&#10;Decoding compiled method 0x00007fbe883ddcd0:&#10;Code:&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;run&#39; &#39;()V&#39; in &#39;MemoryBarrierDemo$1&#39;&#10;  0x00007fbe883dde20: callq  0x00007fbe90e52370  ;   &#123;runtime_call&#125;&#10;  0x00007fbe883dde25: nopw   0x0(%rax,%rax,1)&#10;  0x00007fbe883dde30: mov    %eax,-0x14000(%rsp)&#10;  0x00007fbe883dde37: push   %rbp&#10;  0x00007fbe883dde38: sub    $0x10,%rsp&#10;  0x00007fbe883dde3c: mov    (%rsi),%ebx&#10;  0x00007fbe883dde3e: mov    %rsi,%rdi&#10;  0x00007fbe883dde41: mov    $0x7fbe90edf400,%r10&#10;  0x00007fbe883dde4b: callq  *%r10              ;*invokestatic access$000&#10;                                                ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;  0x00007fbe883dde4e: mov    $0xebcfc590,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fbe883dde58: movzbl 0x70(%r10),%r11d&#10;  0x00007fbe883dde5d: test   %r11d,%r11d&#10;  0x00007fbe883dde60: jne    0x00007fbe883dde6c  ;*goto&#10;                                                ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;  0x00007fbe883dde62: inc    %ebx               ; OopMap&#123;off=68&#125;&#10;                                                ;*goto&#10;                                                ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;  0x00007fbe883dde64: test   %eax,0x9c6d196(%rip)        # 0x00007fbe9204b000&#10;                                                ;*goto&#10;                                                ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;                                                ;   &#123;poll&#125;&#10;  0x00007fbe883dde6a: jmp    0x00007fbe883dde62&#10;  0x00007fbe883dde6c: mov    $0xebcb0d10,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;java/lang/System&#39;)&#125;&#10;  0x00007fbe883dde76: mov    0x74(%r10),%r11d   ;*getstatic out&#10;                                                ; - MemoryBarrierDemo$1::run@14 (line 13)&#10;  0x00007fbe883dde7a: test   %r11d,%r11d&#10;  0x00007fbe883dde7d: je     0x00007fbe883ddea0  ;*ifne&#10;                                                ; - MemoryBarrierDemo$1::run@5 (line 10)&#10;  0x00007fbe883dde7f: mov    %r11,%rsi          ;*getstatic out&#10;                                                ; - MemoryBarrierDemo$1::run@14 (line 13)&#10;  0x00007fbe883dde82: mov    $0xebd4b960,%rdx   ;   &#123;oop(&#34;Done!&#34;)&#125;&#10;  0x00007fbe883dde8c: xchg   %ax,%ax&#10;  0x00007fbe883dde8f: callq  0x00007fbe883b5c60  ; OopMap&#123;off=116&#125;&#10;                                                ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;                                                ;   &#123;optimized virtual_call&#125;&#10;  0x00007fbe883dde94: add    $0x10,%rsp&#10;  0x00007fbe883dde98: pop    %rbp&#10;  0x00007fbe883dde99: test   %eax,0x9c6d161(%rip)        # 0x00007fbe9204b000&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fbe883dde9f: retq&#10;  0x00007fbe883ddea0: mov    $0xfffffff6,%esi&#10;  0x00007fbe883ddea5: xchg   %ax,%ax&#10;  0x00007fbe883ddea7: callq  0x00007fbe883b7020  ; OopMap&#123;off=140&#125;&#10;                                                ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbe883ddeac: callq  0x00007fbe90e52370  ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbe883ddeb1: mov    %rax,%rsi&#10;  0x00007fbe883ddeb4: add    $0x10,%rsp&#10;  0x00007fbe883ddeb8: pop    %rbp&#10;  0x00007fbe883ddeb9: jmpq   0x00007fbe883df5e0  ;*iinc&#10;                                                ; - MemoryBarrierDemo$1::run@8 (line 11)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbe883ddebe: callq  0x00007fbe90e52370  ;   &#123;runtime_call&#125;&#10;  0x00007fbe883ddec3: hlt&#10;  0x00007fbe883ddec4: hlt&#10;  0x00007fbe883ddec5: hlt&#10;  0x00007fbe883ddec6: hlt&#10;  0x00007fbe883ddec7: hlt&#10;  0x00007fbe883ddec8: hlt&#10;  0x00007fbe883ddec9: hlt&#10;  0x00007fbe883ddeca: hlt&#10;  0x00007fbe883ddecb: hlt&#10;  0x00007fbe883ddecc: hlt&#10;  0x00007fbe883ddecd: hlt&#10;  0x00007fbe883ddece: hlt&#10;  0x00007fbe883ddecf: hlt&#10;  0x00007fbe883dded0: hlt&#10;  0x00007fbe883dded1: hlt&#10;  0x00007fbe883dded2: hlt&#10;  0x00007fbe883dded3: hlt&#10;  0x00007fbe883dded4: hlt&#10;  0x00007fbe883dded5: hlt&#10;  0x00007fbe883dded6: hlt&#10;  0x00007fbe883dded7: hlt&#10;  0x00007fbe883dded8: hlt&#10;  0x00007fbe883dded9: hlt&#10;  0x00007fbe883ddeda: hlt&#10;  0x00007fbe883ddedb: hlt&#10;  0x00007fbe883ddedc: hlt&#10;  0x00007fbe883ddedd: hlt&#10;  0x00007fbe883ddede: hlt&#10;  0x00007fbe883ddedf: hlt&#10;[Stub Code]&#10;  0x00007fbe883ddee0: mov    $0x0,%rbx          ;   &#123;no_reloc&#125;&#10;  0x00007fbe883ddeea: jmpq   0x00007fbe883ddeea  ;   &#123;runtime_call&#125;&#10;[Exception Handler]&#10;  0x00007fbe883ddeef: jmpq   0x00007fbe883dc860  ;   &#123;runtime_call&#125;&#10;[Deopt Handler Code]&#10;  0x00007fbe883ddef4: callq  0x00007fbe883ddef9&#10;  0x00007fbe883ddef9: subq   $0x5,(%rsp)&#10;  0x00007fbe883ddefe: jmpq   0x00007fbe883b6c00  ;   &#123;runtime_call&#125;&#10;  0x00007fbe883ddf03: hlt&#10;  0x00007fbe883ddf04: hlt&#10;  0x00007fbe883ddf05: hlt&#10;  0x00007fbe883ddf06: hlt&#10;  0x00007fbe883ddf07: hlt&#10;flag cancel set to true</span><br></pre></td></tr></table></figure>
<p>带有volatile的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuan@yuan-HP:~/learn$ jdk1.7.0_25/bin/java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly MemoryBarrierDemo&#10;Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output&#10;OS: Linux amd64&#10;JavaVersion: 1.7.0_25&#10;&#10;Loaded disassembler from /home/yuan/learn/jdk1.7.0_25/jre/lib/amd64/hsdis-amd64.so&#10;Decoding compiled method 0x00007fb865061890:&#10;Code:&#10;[Disassembling for mach=&#39;i386:x86-64&#39;]&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;access$000&#39; &#39;()Z&#39; in &#39;MemoryBarrierDemo&#39;&#10;  #           [sp+0x20]  (sp of caller)&#10;  0x00007fb8650619c0: sub    $0x18,%rsp&#10;  0x00007fb8650619c7: mov    %rbp,0x10(%rsp)    ;*synchronization entry&#10;                                                ; - MemoryBarrierDemo::access$000@-1 (line 1)&#10;  0x00007fb8650619cc: mov    $0xebcfc590,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fb8650619d6: movzbl 0x70(%r10),%eax    ;*getstatic cancel&#10;                                                ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;  0x00007fb8650619db: add    $0x10,%rsp&#10;  0x00007fb8650619df: pop    %rbp&#10;  0x00007fb8650619e0: test   %eax,0xb55e61a(%rip)        # 0x00007fb8705c0000&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fb8650619e6: retq&#10;  0x00007fb8650619e7: hlt&#10;  0x00007fb8650619e8: hlt&#10;  0x00007fb8650619e9: hlt&#10;  0x00007fb8650619ea: hlt&#10;  0x00007fb8650619eb: hlt&#10;  0x00007fb8650619ec: hlt&#10;  0x00007fb8650619ed: hlt&#10;  0x00007fb8650619ee: hlt&#10;  0x00007fb8650619ef: hlt&#10;  0x00007fb8650619f0: hlt&#10;  0x00007fb8650619f1: hlt&#10;  0x00007fb8650619f2: hlt&#10;  0x00007fb8650619f3: hlt&#10;  0x00007fb8650619f4: hlt&#10;  0x00007fb8650619f5: hlt&#10;  0x00007fb8650619f6: hlt&#10;  0x00007fb8650619f7: hlt&#10;  0x00007fb8650619f8: hlt&#10;  0x00007fb8650619f9: hlt&#10;  0x00007fb8650619fa: hlt&#10;  0x00007fb8650619fb: hlt&#10;  0x00007fb8650619fc: hlt&#10;  0x00007fb8650619fd: hlt&#10;  0x00007fb8650619fe: hlt&#10;  0x00007fb8650619ff: hlt&#10;[Exception Handler]&#10;[Stub Code]&#10;  0x00007fb865061a00: jmpq   0x00007fb86505e860  ;   &#123;no_reloc&#125;&#10;[Deopt Handler Code]&#10;  0x00007fb865061a05: callq  0x00007fb865061a0a&#10;  0x00007fb865061a0a: subq   $0x5,(%rsp)&#10;  0x00007fb865061a0f: jmpq   0x00007fb865038c00  ;   &#123;runtime_call&#125;&#10;  0x00007fb865061a14: hlt&#10;  0x00007fb865061a15: hlt&#10;  0x00007fb865061a16: hlt&#10;  0x00007fb865061a17: hlt&#10;Decoding compiled method 0x00007fb86505fc90:&#10;Code:&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;run&#39; &#39;()V&#39; in &#39;MemoryBarrierDemo$1&#39;&#10;  0x00007fb86505fde0: callq  0x00007fb86f3c7370  ;   &#123;runtime_call&#125;&#10;  0x00007fb86505fde5: nopw   0x0(%rax,%rax,1)&#10;  0x00007fb86505fdf0: mov    %eax,-0x14000(%rsp)&#10;  0x00007fb86505fdf7: push   %rbp&#10;  0x00007fb86505fdf8: sub    $0x10,%rsp&#10;  0x00007fb86505fdfc: mov    (%rsi),%ebp&#10;  0x00007fb86505fdfe: mov    %rsi,%rdi&#10;  0x00007fb86505fe01: mov    $0x7fb86f454400,%r10&#10;  0x00007fb86505fe0b: callq  *%r10              ;*synchronization entry&#10;                                                ; - MemoryBarrierDemo::access$000@-1 (line 1)&#10;                                                ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;  0x00007fb86505fe0e: mov    $0xebcfc590,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fb86505fe18: movzbl 0x70(%r10),%r8d    ;*getstatic cancel&#10;                                                ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;                                                ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;  0x00007fb86505fe1d: test   %r8d,%r8d&#10;  0x00007fb86505fe20: jne    0x00007fb86505fe42  ;*ifne&#10;                                                ; - MemoryBarrierDemo$1::run@5 (line 10)&#10;  0x00007fb86505fe22: nopw   0x0(%rax,%rax,1)&#10;  0x00007fb86505fe2c: xchg   %ax,%ax            ;*iinc&#10;                                                ; - MemoryBarrierDemo$1::run@8 (line 11)&#10;  0x00007fb86505fe30: movzbl 0x70(%r10),%r11d   ;*getstatic cancel&#10;                                                ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;                                                ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;  0x00007fb86505fe35: inc    %ebp               ; OopMap&#123;r10=Oop off=87&#125;&#10;                                                ;*goto&#10;                                                ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;  0x00007fb86505fe37: test   %eax,0xb5601c3(%rip)        # 0x00007fb8705c0000&#10;                                                ;*getstatic cancel&#10;                                                ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;                                                ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;                                                ;   &#123;poll&#125;&#10;  0x00007fb86505fe3d: test   %r11d,%r11d&#10;  0x00007fb86505fe40: je     0x00007fb86505fe30  ;*ifne&#10;                                                ; - MemoryBarrierDemo$1::run@5 (line 10)&#10;  0x00007fb86505fe42: mov    $0xebcb0d10,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;java/lang/System&#39;)&#125;&#10;  0x00007fb86505fe4c: mov    0x74(%r10),%r10d   ;*getstatic out&#10;                                                ; - MemoryBarrierDemo$1::run@14 (line 13)&#10;  0x00007fb86505fe50: test   %r10d,%r10d&#10;  0x00007fb86505fe53: je     0x00007fb86505fe74  ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;  0x00007fb86505fe55: mov    %r10,%rsi          ;*getstatic out&#10;                                                ; - MemoryBarrierDemo$1::run@14 (line 13)&#10;  0x00007fb86505fe58: mov    $0xebd4b960,%rdx   ;   &#123;oop(&#34;Done!&#34;)&#125;&#10;  0x00007fb86505fe62: nop&#10;  0x00007fb86505fe63: callq  0x00007fb865037c60  ; OopMap&#123;off=136&#125;&#10;                                                ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;                                                ;   &#123;optimized virtual_call&#125;&#10;  0x00007fb86505fe68: add    $0x10,%rsp&#10;  0x00007fb86505fe6c: pop    %rbp&#10;  0x00007fb86505fe6d: test   %eax,0xb56018d(%rip)        # 0x00007fb8705c0000&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fb86505fe73: retq&#10;  0x00007fb86505fe74: mov    $0xfffffff6,%esi&#10;  0x00007fb86505fe79: xchg   %ax,%ax&#10;  0x00007fb86505fe7b: callq  0x00007fb865039020  ; OopMap&#123;off=160&#125;&#10;                                                ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fb86505fe80: callq  0x00007fb86f3c7370  ;*invokevirtual println&#10;                                                ; - MemoryBarrierDemo$1::run@19 (line 13)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fb86505fe85: mov    %rax,%rsi&#10;  0x00007fb86505fe88: add    $0x10,%rsp&#10;  0x00007fb86505fe8c: pop    %rbp&#10;  0x00007fb86505fe8d: jmpq   0x00007fb8650615e0  ;   &#123;runtime_call&#125;&#10;  0x00007fb86505fe92: hlt&#10;  0x00007fb86505fe93: hlt&#10;  0x00007fb86505fe94: hlt&#10;  0x00007fb86505fe95: hlt&#10;  0x00007fb86505fe96: hlt&#10;  0x00007fb86505fe97: hlt&#10;  0x00007fb86505fe98: hlt&#10;  0x00007fb86505fe99: hlt&#10;  0x00007fb86505fe9a: hlt&#10;  0x00007fb86505fe9b: hlt&#10;  0x00007fb86505fe9c: hlt&#10;  0x00007fb86505fe9d: hlt&#10;  0x00007fb86505fe9e: hlt&#10;  0x00007fb86505fe9f: hlt&#10;[Stub Code]&#10;  0x00007fb86505fea0: mov    $0x0,%rbx          ;   &#123;no_reloc&#125;&#10;  0x00007fb86505feaa: jmpq   0x00007fb86505feaa  ;   &#123;runtime_call&#125;&#10;[Exception Handler]&#10;  0x00007fb86505feaf: jmpq   0x00007fb86505e860  ;   &#123;runtime_call&#125;&#10;[Deopt Handler Code]&#10;  0x00007fb86505feb4: callq  0x00007fb86505feb9&#10;  0x00007fb86505feb9: subq   $0x5,(%rsp)&#10;  0x00007fb86505febe: jmpq   0x00007fb865038c00  ;   &#123;runtime_call&#125;&#10;  0x00007fb86505fec3: hlt&#10;  0x00007fb86505fec4: hlt&#10;  0x00007fb86505fec5: hlt&#10;  0x00007fb86505fec6: hlt&#10;  0x00007fb86505fec7: hlt&#10;flag cancel set to true&#10;Done!&#10;yuan@yuan-HP:~/learn$</span><br></pre></td></tr></table></figure>
<p>现在我们分析一下。在没有volatile的版本中，循环递增部分的汇编代码很有趣，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007fbe883dde58: movzbl 0x70(%r10),%r11d&#10;0x00007fbe883dde5d: test   %r11d,%r11d&#10;0x00007fbe883dde60: jne    0x00007fbe883dde6c  ;*goto&#10;                                              ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;0x00007fbe883dde62: inc    %ebx               ; OopMap&#123;off=68&#125;&#10;                                              ;*goto&#10;                                              ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;0x00007fbe883dde64: test   %eax,0x9c6d196(%rip)        # 0x00007fbe9204b000&#10;                                              ;*goto&#10;                                              ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;                                              ;   &#123;poll&#125;&#10;0x00007fbe883dde6a: jmp    0x00007fbe883dde62</span><br></pre></td></tr></table></figure>
<p>进入循环时检查过一次<code>cancel</code>，但是在后面却成了<code>jmp</code>无条件跳转，可想而知这肯定是编译器的“功劳”。在此笔者就先不深究这里所做的编译优化的原因了，只是简单的相信编译器已经获得了足够多的信息来判断<code>cancel</code>值在该线程是不变的。反过来推理，编译器的开发者肯定是对硬件层面的memory barrier有深入的理解才会做这个优化，这样也是本文想要探索的。</p>
<p>在带有volatile的版本中，循环递增部分的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007fb86505fe18: movzbl 0x70(%r10),%r8d    ;*getstatic cancel&#10;                                              ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;                                              ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;0x00007fb86505fe1d: test   %r8d,%r8d&#10;0x00007fb86505fe20: jne    0x00007fb86505fe42  ;*ifne&#10;                                              ; - MemoryBarrierDemo$1::run@5 (line 10)&#10;0x00007fb86505fe22: nopw   0x0(%rax,%rax,1)&#10;0x00007fb86505fe2c: xchg   %ax,%ax            ;*iinc&#10;                                              ; - MemoryBarrierDemo$1::run@8 (line 11)&#10;0x00007fb86505fe30: movzbl 0x70(%r10),%r11d   ;*getstatic cancel&#10;                                              ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;                                              ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;0x00007fb86505fe35: inc    %ebp               ; OopMap&#123;r10=Oop off=87&#125;&#10;                                              ;*goto&#10;                                              ; - MemoryBarrierDemo$1::run@11 (line 11)&#10;0x00007fb86505fe37: test   %eax,0xb5601c3(%rip)        # 0x00007fb8705c0000&#10;                                              ;*getstatic cancel&#10;                                              ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;                                              ; - MemoryBarrierDemo$1::run@2 (line 10)&#10;                                              ;   &#123;poll&#125;&#10;0x00007fb86505fe3d: test   %r11d,%r11d&#10;0x00007fb86505fe40: je     0x00007fb86505fe30  ;*ifne&#10;                                              ; - MemoryBarrierDemo$1::run@5 (line 10)&#10;0x00007fb86505fe42: mov    $0xebcb0d10,%r10   ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;java/lang/System&#39;)&#125;</span><br></pre></td></tr></table></figure>
<p>该版本的主要不同是在于获取cacel前执行了<code>xchg   %ax,%ax</code>。</p>
<p>xchg是什么东东？查_Intel 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes 3A, 3B, and 3C: System Programming Guide_：</p>
<p>8-3页：</p>
<blockquote>
<p>8.1.2 Bus Locking</p>
</blockquote>
<blockquote>
<p>Intel 64 and IA-32 processors provide a LOCK# signal that is asserted automatically during certain critical memory operations to lock the system bus or equivalent link. While this output signal is asserted, requests from other processors or bus agents for control of the bus are blocked. Software can specify other occasions when the LOCK semantics are to be followed by prepending the LOCK prefix to an instruction.</p>
</blockquote>
<blockquote>
<p>In the case of the Intel386, Intel486, and Pentium processors , explicitly locked instructions will result in the assertion of the LOCK# signal. It is the responsibility of the hardware designer to make the LOCK# signal available in system hardware to control memory accesses among processors.</p>
</blockquote>
<blockquote>
<p>For the P6 and more recent processor families, if the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted; instead, locking is only applied to the processor’s caches (see Section 8.1.4, “Effects of a LOCK Operation on Internal Processor Caches”).</p>
</blockquote>
<blockquote>
<p>8.1.2.1 Automatic Locking</p>
</blockquote>
<blockquote>
<p>The operations on which the processor automatically follows the LOCK semantics are as follows:</p>
</blockquote>
<blockquote>
<p>• When executing an XCHG instruction that references memory.</p>
</blockquote>
<p>8-15页：</p>
<blockquote>
<p>Synchronization mechanisms in multiple-processor systems may depend upon a strong memory-ordering model. Here, a program can use a locking instruction such as the XCHG instruction or the LOCK prefix to ensure that a read-modify-write operation on memory is carried out atomically. Locking operations typically operate like I/O operations in that they wait for all previous instructions to complete and for all buffered writes to drain to memory (see Section 8.1.2, “Bus Locking”).</p>
</blockquote>
<p>8-16页：</p>
<blockquote>
<p>Intel recommends that software written to run on Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium 4, Intel Xeon, and P6 family processors assume the processor-ordering model or a weaker memory-ordering model. The Intel Core 2 Duo, Intel Atom, Intel Core Duo, Pentium 4, Intel Xeon, and P6 family processors do not implement a strong memory-ordering model, except when using the UC memory type. Despite the fact that Pentium 4, Intel Xeon, and P6 family processors support processor ordering, Intel does not guarantee that future processors will support this model. To make software portable to futu re processors, it is recommended that operating systems provide critical region and resource control constructs and API’s (application program interfaces) based on I/O, locking, and/or serializing instructions be used to synchronize access to shared areas of memory in multiple-processor systems. Also, software should not depend on processor ordering in situations where the system hardware does not support this memory-ordering model.</p>
</blockquote>
<p>读完之后，笔者大致了解了三点：</p>
<ol style="list-style-type: decimal">
<li><p>执行XCHG指令会自动跟随LOCK语义；</p></li>
<li><p>locking操作会等待前面所有的指令完成，并且将所有buffered writes写到内存；</p></li>
<li><p>memory-ordering model的强度是变化的，软件不能依赖processor ordering。这就解释了第一个版本中的编译优化，编译器从高级语言中得不到显式的信息（比如Locking和volatile），所以就默认使用processor-ordering model，编译器就会尽可能的优化性能；而在第二个版本中，有显式的volatile关键字，所以编译器就会加入XCHG指令，以实现strong memory-ordering model。</p></li>
</ol>
<p>等一下，好像哪里有问题。就算<code>xchg</code>触发了<code>LOCK</code>语义，但是缓存中的<code>cancel</code>并没有改变，所以也不会触发cache coherency protocol；就算<code>cancel</code>所在的cache line由于别的原因被修改了，而此前主线程没有对<code>cancel</code>进行修改的话，也是没有用呀。再从头开始想想这个逻辑，如果让笔者设计编译器，笔者应该会在<code>cancel = true;</code>这行之后加上LOCK语义。再回过头看看汇编代码，竟然找不到对应的代码！</p>
<p>经过笔者多次尝试，最后通过加入<code>-Xcomp</code>打印出了所需的信息，另外对Java代码也做了点儿改动。（笔者对此有蛮多疑惑，暂且存疑吧-_-）</p>
<p>修改后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancel = <span class="keyword">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                cancel = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">while</span> (!cancel) &#123;</span><br><span class="line">                                        i++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                System.out.println(<span class="string">"Done!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"OS: "</span> + System.getProperty(<span class="string">"os.name"</span>) + <span class="string">" "</span> + System.getProperty(<span class="string">"os.arch"</span>) + <span class="string">"\n"</span></span><br><span class="line">                                + <span class="string">"JavaVersion: "</span> + System.getProperty(<span class="string">"java.version"</span>) + <span class="string">"\n"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2048</span>);</span><br><span class="line">                <span class="comment">//cancel = true;</span></span><br><span class="line">                setCancel();</span><br><span class="line">                System.out.println(<span class="string">"flag cancel set to true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuan@yuan-HP:~/learn$ jdk1.7.0_25/bin/java -Xcomp  -XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,MemoryBarrierDemo.* MemoryBarrierDemo&#10;CompilerOracle: print MemoryBarrierDemo.*&#10;Java HotSpot(TM) 64-Bit Server VM warning: printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional output&#10;Compiled method (c2)     888  370             MemoryBarrierDemo::&#60;clinit&#62; (5 bytes)&#10; total in heap  [0x00007fbaec8ae2d0,0x00007fbaec8ae4a0] = 464&#10; relocation     [0x00007fbaec8ae3f0,0x00007fbaec8ae400] = 16&#10; main code      [0x00007fbaec8ae400,0x00007fbaec8ae440] = 64&#10; stub code      [0x00007fbaec8ae440,0x00007fbaec8ae458] = 24&#10; oops           [0x00007fbaec8ae458,0x00007fbaec8ae460] = 8&#10; scopes data    [0x00007fbaec8ae460,0x00007fbaec8ae468] = 8&#10; scopes pcs     [0x00007fbaec8ae468,0x00007fbaec8ae498] = 48&#10; dependencies   [0x00007fbaec8ae498,0x00007fbaec8ae4a0] = 8&#10;Loaded disassembler from /home/yuan/learn/jdk1.7.0_25/jre/lib/amd64/hsdis-amd64.so&#10;Decoding compiled method 0x00007fbaec8ae2d0:&#10;Code:&#10;[Disassembling for mach=&#39;i386:x86-64&#39;]&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;&#60;clinit&#62;&#39; &#39;()V&#39; in &#39;MemoryBarrierDemo&#39;&#10;  #           [sp+0x20]  (sp of caller)&#10;  0x00007fbaec8ae400: sub    $0x18,%rsp         ;...4881ec18 000000&#10;  0x00007fbaec8ae407: mov    %rbp,0x10(%rsp)    ;...48896c24 10&#10;  0x00007fbaec8ae40c: mov    $0xebd9deb8,%r10   ;...49bab8de d9eb00&#10;                                                ;...000000&#10;                                                ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fbaec8ae416: mov    %r12b,0x70(%r10)   ;...45886270&#10;  0x00007fbaec8ae41a: lock addl $0x0,(%rsp)     ;...f0830424 00&#10;                                                ;*putstatic cancel&#10;                                                ; - MemoryBarrierDemo::&#60;clinit&#62;@1 (line 3)&#10;  0x00007fbaec8ae41f: add    $0x10,%rsp         ;...4883c410&#10;  0x00007fbaec8ae423: pop    %rbp               ;...5d&#10;  0x00007fbaec8ae424: test   %eax,0x9c59bd6(%rip)        # 0x00007fbaf6508000&#10;                                                ;...8505d69b c509&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fbaec8ae42a: retq                      ;...c3&#10;  0x00007fbaec8ae42b: hlt                       ;...f4&#10;  0x00007fbaec8ae42c: hlt                       ;...f4&#10;  0x00007fbaec8ae42d: hlt                       ;...f4&#10;  0x00007fbaec8ae42e: hlt                       ;...f4&#10;  0x00007fbaec8ae42f: hlt                       ;...f4&#10;  0x00007fbaec8ae430: hlt                       ;...f4&#10;  0x00007fbaec8ae431: hlt                       ;...f4&#10;  0x00007fbaec8ae432: hlt                       ;...f4&#10;  0x00007fbaec8ae433: hlt                       ;...f4&#10;  0x00007fbaec8ae434: hlt                       ;...f4&#10;  0x00007fbaec8ae435: hlt                       ;...f4&#10;  0x00007fbaec8ae436: hlt                       ;...f4&#10;  0x00007fbaec8ae437: hlt                       ;...f4&#10;  0x00007fbaec8ae438: hlt                       ;...f4&#10;  0x00007fbaec8ae439: hlt                       ;...f4&#10;  0x00007fbaec8ae43a: hlt                       ;...f4&#10;  0x00007fbaec8ae43b: hlt                       ;...f4&#10;  0x00007fbaec8ae43c: hlt                       ;...f4&#10;  0x00007fbaec8ae43d: hlt                       ;...f4&#10;  0x00007fbaec8ae43e: hlt                       ;...f4&#10;  0x00007fbaec8ae43f: hlt                       ;...f4&#10;[Exception Handler]&#10;[Stub Code]&#10;  0x00007fbaec8ae440: jmpq   0x00007fbaec80f860  ;...e91b14f6 ff&#10;                                                ;   &#123;no_reloc&#125;&#10;[Deopt Handler Code]&#10;  0x00007fbaec8ae445: callq  0x00007fbaec8ae44a  ;...e8000000 00&#10;  0x00007fbaec8ae44a: subq   $0x5,(%rsp)        ;...48832c24 05&#10;  0x00007fbaec8ae44f: jmpq   0x00007fbaec7eac00  ;...e9acc7f3 ff&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbaec8ae454: hlt                       ;...f4&#10;  0x00007fbaec8ae455: hlt                       ;...f4&#10;  0x00007fbaec8ae456: hlt                       ;...f4&#10;  0x00007fbaec8ae457: hlt                       ;...f4&#10;OopMapSet contains 0 OopMaps&#10;&#10;Compiled method (c2)     893  371             MemoryBarrierDemo::main (100 bytes)&#10; total in heap  [0x00007fbaec8b10d0,0x00007fbaec8b12b0] = 480&#10; relocation     [0x00007fbaec8b11f0,0x00007fbaec8b1200] = 16&#10; main code      [0x00007fbaec8b1200,0x00007fbaec8b1220] = 32&#10; stub code      [0x00007fbaec8b1220,0x00007fbaec8b1238] = 24&#10; oops           [0x00007fbaec8b1238,0x00007fbaec8b1240] = 8&#10; scopes data    [0x00007fbaec8b1240,0x00007fbaec8b1258] = 24&#10; scopes pcs     [0x00007fbaec8b1258,0x00007fbaec8b12a8] = 80&#10; dependencies   [0x00007fbaec8b12a8,0x00007fbaec8b12b0] = 8&#10;Decoding compiled method 0x00007fbaec8b10d0:&#10;Code:&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;main&#39; &#39;([Ljava/lang/String;)V&#39; in &#39;MemoryBarrierDemo&#39;&#10;  # parm0:    rsi:rsi   = &#39;[Ljava/lang/String;&#39;&#10;  #           [sp+0x20]  (sp of caller)&#10;  0x00007fbaec8b1200: mov    %eax,-0x14000(%rsp)  ;...89842400 c0feff&#10;  0x00007fbaec8b1207: push   %rbp               ;...55&#10;  0x00007fbaec8b1208: sub    $0x10,%rsp         ;...4883ec10&#10;                                                ;*synchronization entry&#10;                                                ; - MemoryBarrierDemo::main@-1 (line 9)&#10;  0x00007fbaec8b120c: mov    $0x3,%esi          ;...be030000 00&#10;  0x00007fbaec8b1211: xchg   %ax,%ax            ;...6690&#10;  0x00007fbaec8b1213: callq  0x00007fbaec7eb020  ;...e8089ef3 ff&#10;                                                ; OopMap&#123;off=24&#125;&#10;                                                ;*new  ; - MemoryBarrierDemo::main@0 (line 9)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbaec8b1218: callq  0x00007fbaf530f370  ;...e853e1a5 08&#10;                                                ;*new  ; - MemoryBarrierDemo::main@0 (line 9)&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbaec8b121d: hlt                       ;...f4&#10;  0x00007fbaec8b121e: hlt                       ;...f4&#10;  0x00007fbaec8b121f: hlt                       ;...f4&#10;[Exception Handler]&#10;[Stub Code]&#10;  0x00007fbaec8b1220: jmpq   0x00007fbaec80f860  ;...e93be6f5 ff&#10;                                                ;   &#123;no_reloc&#125;&#10;[Deopt Handler Code]&#10;  0x00007fbaec8b1225: callq  0x00007fbaec8b122a  ;...e8000000 00&#10;  0x00007fbaec8b122a: subq   $0x5,(%rsp)        ;...48832c24 05&#10;  0x00007fbaec8b122f: jmpq   0x00007fbaec7eac00  ;...e9cc99f3 ff&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbaec8b1234: hlt                       ;...f4&#10;  0x00007fbaec8b1235: hlt                       ;...f4&#10;  0x00007fbaec8b1236: hlt                       ;...f4&#10;  0x00007fbaec8b1237: hlt                       ;...f4&#10;OopMapSet contains 1 OopMaps&#10;&#10;#0&#10;OopMap&#123;off=24&#125;&#10;Compiled method (c2)     994  398             MemoryBarrierDemo::access$000 (4 bytes)&#10; total in heap  [0x00007fbaec8b9390,0x00007fbaec8b9578] = 488&#10; relocation     [0x00007fbaec8b94b0,0x00007fbaec8b94c0] = 16&#10; main code      [0x00007fbaec8b94c0,0x00007fbaec8b9500] = 64&#10; stub code      [0x00007fbaec8b9500,0x00007fbaec8b9518] = 24&#10; oops           [0x00007fbaec8b9518,0x00007fbaec8b9520] = 8&#10; scopes data    [0x00007fbaec8b9520,0x00007fbaec8b9530] = 16&#10; scopes pcs     [0x00007fbaec8b9530,0x00007fbaec8b9570] = 64&#10; dependencies   [0x00007fbaec8b9570,0x00007fbaec8b9578] = 8&#10;Decoding compiled method 0x00007fbaec8b9390:&#10;Code:&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;access$000&#39; &#39;()Z&#39; in &#39;MemoryBarrierDemo&#39;&#10;  #           [sp+0x20]  (sp of caller)&#10;  0x00007fbaec8b94c0: sub    $0x18,%rsp         ;...4881ec18 000000&#10;  0x00007fbaec8b94c7: mov    %rbp,0x10(%rsp)    ;...48896c24 10&#10;                                                ;*synchronization entry&#10;                                                ; - MemoryBarrierDemo::access$000@-1 (line 1)&#10;  0x00007fbaec8b94cc: mov    $0xebd9deb8,%r10   ;...49bab8de d9eb00&#10;                                                ;...000000&#10;                                                ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fbaec8b94d6: movzbl 0x70(%r10),%eax    ;...410fb642 70&#10;                                                ;*getstatic cancel&#10;                                                ; - MemoryBarrierDemo::access$000@0 (line 1)&#10;  0x00007fbaec8b94db: add    $0x10,%rsp         ;...4883c410&#10;  0x00007fbaec8b94df: pop    %rbp               ;...5d&#10;  0x00007fbaec8b94e0: test   %eax,0x9c4eb1a(%rip)        # 0x00007fbaf6508000&#10;                                                ;...85051aeb c409&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fbaec8b94e6: retq                      ;...c3&#10;  0x00007fbaec8b94e7: hlt                       ;...f4&#10;  0x00007fbaec8b94e8: hlt                       ;...f4&#10;  0x00007fbaec8b94e9: hlt                       ;...f4&#10;  0x00007fbaec8b94ea: hlt                       ;...f4&#10;  0x00007fbaec8b94eb: hlt                       ;...f4&#10;  0x00007fbaec8b94ec: hlt                       ;...f4&#10;  0x00007fbaec8b94ed: hlt                       ;...f4&#10;  0x00007fbaec8b94ee: hlt                       ;...f4&#10;  0x00007fbaec8b94ef: hlt                       ;...f4&#10;  0x00007fbaec8b94f0: hlt                       ;...f4&#10;  0x00007fbaec8b94f1: hlt                       ;...f4&#10;  0x00007fbaec8b94f2: hlt                       ;...f4&#10;  0x00007fbaec8b94f3: hlt                       ;...f4&#10;  0x00007fbaec8b94f4: hlt                       ;...f4&#10;  0x00007fbaec8b94f5: hlt                       ;...f4&#10;  0x00007fbaec8b94f6: hlt                       ;...f4&#10;  0x00007fbaec8b94f7: hlt                       ;...f4&#10;  0x00007fbaec8b94f8: hlt                       ;...f4&#10;  0x00007fbaec8b94f9: hlt                       ;...f4&#10;  0x00007fbaec8b94fa: hlt                       ;...f4&#10;  0x00007fbaec8b94fb: hlt                       ;...f4&#10;  0x00007fbaec8b94fc: hlt                       ;...f4&#10;  0x00007fbaec8b94fd: hlt                       ;...f4&#10;  0x00007fbaec8b94fe: hlt                       ;...f4&#10;  0x00007fbaec8b94ff: hlt                       ;...f4&#10;[Exception Handler]&#10;[Stub Code]&#10;  0x00007fbaec8b9500: jmpq   0x00007fbaec80f860  ;...e95b63f5 ff&#10;                                                ;   &#123;no_reloc&#125;&#10;[Deopt Handler Code]&#10;  0x00007fbaec8b9505: callq  0x00007fbaec8b950a  ;...e8000000 00&#10;  0x00007fbaec8b950a: subq   $0x5,(%rsp)        ;...48832c24 05&#10;  0x00007fbaec8b950f: jmpq   0x00007fbaec7eac00  ;...e9ec16f3 ff&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbaec8b9514: hlt                       ;...f4&#10;  0x00007fbaec8b9515: hlt                       ;...f4&#10;  0x00007fbaec8b9516: hlt                       ;...f4&#10;  0x00007fbaec8b9517: hlt                       ;...f4&#10;OopMapSet contains 0 OopMaps&#10;&#10;OS: Linux amd64&#10;JavaVersion: 1.7.0_25&#10;&#10;Compiled method (c2)    3101  428             MemoryBarrierDemo::setCancel (5 bytes)&#10; total in heap  [0x00007fbaec896b90,0x00007fbaec896d60] = 464&#10; relocation     [0x00007fbaec896cb0,0x00007fbaec896cc0] = 16&#10; main code      [0x00007fbaec896cc0,0x00007fbaec896d00] = 64&#10; stub code      [0x00007fbaec896d00,0x00007fbaec896d18] = 24&#10; oops           [0x00007fbaec896d18,0x00007fbaec896d20] = 8&#10; scopes data    [0x00007fbaec896d20,0x00007fbaec896d28] = 8&#10; scopes pcs     [0x00007fbaec896d28,0x00007fbaec896d58] = 48&#10; dependencies   [0x00007fbaec896d58,0x00007fbaec896d60] = 8&#10;Decoding compiled method 0x00007fbaec896b90:&#10;Code:&#10;[Entry Point]&#10;[Verified Entry Point]&#10;[Constants]&#10;  # &#123;method&#125; &#39;setCancel&#39; &#39;()V&#39; in &#39;MemoryBarrierDemo&#39;&#10;  #           [sp+0x20]  (sp of caller)&#10;  0x00007fbaec896cc0: sub    $0x18,%rsp         ;...4881ec18 000000&#10;  0x00007fbaec896cc7: mov    %rbp,0x10(%rsp)    ;...48896c24 10&#10;  0x00007fbaec896ccc: mov    $0xebd9deb8,%r10   ;...49bab8de d9eb00&#10;                                                ;...000000&#10;                                                ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;  0x00007fbaec896cd6: movb   $0x1,0x70(%r10)    ;...41c64270 01&#10;  0x00007fbaec896cdb: lock addl $0x0,(%rsp)     ;...f0830424 00&#10;                                                ;*putstatic cancel&#10;                                                ; - MemoryBarrierDemo::setCancel@1 (line 5)&#10;  0x00007fbaec896ce0: add    $0x10,%rsp         ;...4883c410&#10;  0x00007fbaec896ce4: pop    %rbp               ;...5d&#10;  0x00007fbaec896ce5: test   %eax,0x9c71315(%rip)        # 0x00007fbaf6508000&#10;                                                ;...85051513 c709&#10;                                                ;   &#123;poll_return&#125;&#10;  0x00007fbaec896ceb: retq                      ;...c3&#10;  0x00007fbaec896cec: hlt                       ;...f4&#10;  0x00007fbaec896ced: hlt                       ;...f4&#10;  0x00007fbaec896cee: hlt                       ;...f4&#10;  0x00007fbaec896cef: hlt                       ;...f4&#10;  0x00007fbaec896cf0: hlt                       ;...f4&#10;  0x00007fbaec896cf1: hlt                       ;...f4&#10;  0x00007fbaec896cf2: hlt                       ;...f4&#10;  0x00007fbaec896cf3: hlt                       ;...f4&#10;  0x00007fbaec896cf4: hlt                       ;...f4&#10;  0x00007fbaec896cf5: hlt                       ;...f4&#10;  0x00007fbaec896cf6: hlt                       ;...f4&#10;  0x00007fbaec896cf7: hlt                       ;...f4&#10;  0x00007fbaec896cf8: hlt                       ;...f4&#10;  0x00007fbaec896cf9: hlt                       ;...f4&#10;  0x00007fbaec896cfa: hlt                       ;...f4&#10;  0x00007fbaec896cfb: hlt                       ;...f4&#10;  0x00007fbaec896cfc: hlt                       ;...f4&#10;  0x00007fbaec896cfd: hlt                       ;...f4&#10;  0x00007fbaec896cfe: hlt                       ;...f4&#10;  0x00007fbaec896cff: hlt                       ;...f4&#10;[Exception Handler]&#10;[Stub Code]&#10;  0x00007fbaec896d00: jmpq   0x00007fbaec80f860  ;...e95b8bf7 ff&#10;                                                ;   &#123;no_reloc&#125;&#10;[Deopt Handler Code]&#10;  0x00007fbaec896d05: callq  0x00007fbaec896d0a  ;...e8000000 00&#10;  0x00007fbaec896d0a: subq   $0x5,(%rsp)        ;...48832c24 05&#10;  0x00007fbaec896d0f: jmpq   0x00007fbaec7eac00  ;...e9ec3ef5 ff&#10;                                                ;   &#123;runtime_call&#125;&#10;  0x00007fbaec896d14: hlt                       ;...f4&#10;  0x00007fbaec896d15: hlt                       ;...f4&#10;  0x00007fbaec896d16: hlt                       ;...f4&#10;  0x00007fbaec896d17: hlt                       ;...f4&#10;OopMapSet contains 0 OopMaps&#10;&#10;flag cancel set to true&#10;Done!&#10;yuan@yuan-HP:~/learn$</span><br></pre></td></tr></table></figure>
<p>摘出我们所关心的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007fbaec896ccc: mov    $0xebd9deb8,%r10   ;...49bab8de d9eb00&#10;                                              ;...000000&#10;                                              ;   &#123;oop(a &#39;java/lang/Class&#39; = &#39;MemoryBarrierDemo&#39;)&#125;&#10;0x00007fbaec896cd6: movb   $0x1,0x70(%r10)    ;...41c64270 01&#10;0x00007fbaec896cdb: lock addl $0x0,(%rsp)     ;...f0830424 00</span><br></pre></td></tr></table></figure>
<p>在<code>movb   $0x1,0x70(%r10)</code>将<code>cancel</code>设为<code>true</code>之后有一行带有LOCK语义的代码，这就与笔者推理的一致了^_^。</p>
<p>（在这里还有一个让笔者困惑的地方：对于没有volatile的版本，如果执行的时候加了<code>-Xcomp</code>，程序同样可以正常退出，程序行为与加了volatile的版本一致，但是汇编代码中到LOCK。笔者对于JIT完全不懂，所以也只能暂且存疑啦。）</p>
<p>再回过头来整理一下思路。在笔者提供的例子主要是因为没有遵守Java Memory Model，编译器为了性能而做出的优化造成程序无法终止。这其实也不是笔者想要看到的结果，但是通过读_Intel 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes 3A, 3B, and 3C: System Programming Guide_解开了笔者心中的疑惑。</p>
<p>让笔者产生困惑的地方是buffer。</p>
<h2 id="buffer">Buffer</h2>
<p>笔者之前头脑中的CPU模型大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+&#10;| Memory Controller |&#10;+-------------------+&#10;        |&#10;+---------------------------------------------------------------+&#10;| L3                                                            |&#10;+---------------------------------------------------------------+&#10;        |                        |&#10;+-----------------+      +-----------------+&#10;| L1 L2           |      | L1 L2           |    ...&#10;+-----------------+      +-----------------+&#10;        |                        |&#10;+-----------------+      +-----------------+&#10;| Execution Units |      | Execution Units |    ...&#10;+-----------------+      +-----------------+</span><br></pre></td></tr></table></figure>
<p>从执行单元进入L1或L2 cache之后就是cache coherency protocol控制的“天下”了，其它的core肯定就会“看到”相应的改变，怎么还会“看不到”相应的改变呢？这就是让笔者一直困惑的地方。（关于cache coherency，请看<em>支撑处理器的技术</em>的第5.2节）</p>
<p>实际上现代的CPU在执行单元与L1、L2之间还存在Load Buffer、Store Buffer和WCBuffers。它们存在的原因？可想而知是为了弥补执行单元与缓存之间的速度差异，比如<a href="http://mechanical-sympathy.blogspot.com/2011/07/write-combining.html" target="_blank" rel="external">Write Combining</a>技术。对于这三个buffer，x86指令集中有三个细粒度的指令LFENCE、SFENCE和MFENCE控制，在前面所看到的LOCK等同于MFENCE。</p>
<p>在<em>Intel 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes 3A, 3B, and 3C: System Programming Guide</em>的第8-16页：</p>
<blockquote>
<p>The SFENCE, LFENCE, and MFENCE instructions provide a performance-efficient way of ensuring load and store memory ordering between routines that produce weakly-ord ered results and routines that consume that data. The functions of these instructions are as follows:</p>
</blockquote>
<blockquote>
<ul>
<li>SFENCE — Serializes all store (write) operations that occu rred prior to the SFENCE instruction in the program instruction stream, but does not affect load operations.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>LFENCE — Serializes all load (read) operations that occurred prior to the LFENCE instruction in the program instruction stream, but does not affect store operations.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>MFENCE — Serializes all store and load operations that occurred prior to the MFENCE instruction in the program instruction stream.</li>
</ul>
</blockquote>
<p>关于这三个指令与Java语言的关系，请看<a href="http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html" target="_blank" rel="external">Memory Barriers/Fences</a>。这篇文章中还提到了Out of Order的影响，所以本文就不再重复了。</p>
<h2 id="总结">总结</h2>
<ol style="list-style-type: decimal">
<li><p>CPU的“人生价值”就是尽可能的快！为此可以不择手段，比如Write Combining和Out of Order；但是它也提供了LOCK、XCHG、LFENCE、SFENCE、MFENCE等指令满足上层软件同步的需求。</p></li>
<li><p>同步要以牺牲性能为代价。JVM会尽可能优化性能，如果要实现必要的同步就得遵守Java Memory Model，在程序中显式的使用相关机制。</p></li>
<li><p>“Shared mutability is pure evil”（引自_Programming Concurrency on the JVM_）。如果不是legacy系统，笔者肯定优先考虑Actor-based Model。</p></li>
</ol>
 -->
	
	</div>
  <a type="button" href="/2013/08/10/memorybarrier/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-08-07 </div>
			<div class="article-title"><a href="/2013/08/07/disruptor5/" >Disruptor: code overview</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <blockquote>
<p>Producers claim entries in sequence via a <em>ProducerBarrier</em>, write their changes into the claimed entry, then commit that entry back via the <em>ProducerBarrier</em> making them available for consumption. As a consumer all one needs do is provide a <em>BatchHandler</em> implementation that receives call backs when a new entry is available.</p>
</blockquote>
<blockquote>
<p>A <em>RingBuffer</em> exists at the core of the Disruptor pattern providing storage for data exchange without contention. The concurrency concerns are separated out for the producers and consumers interacting with the <em>RingBuffer</em>. The <em>ProducerBarrier</em> manages any concurrency concerns associated with claiming slots in the ring buffer, while tracking dependant consumers to prevent the ring from wrapping. The <em>ConsumerBarrier</em> notifies consumers when new entries are available, and <em>Consumers</em> can be constructed into a graph of dependencies representing multiple stages in a processing pipeline.</p>
</blockquote>
<p>以上文字来自LMAX的官方文档，通过这些文字我们可以大致了解Disruptor的工作流程。下面我们再仔细看看各部分。</p>
<h2 id="ringbuffer">RingBuffer</h2>
<p>其构造方法定义为缺省的，创建RingBuffer实例是通过静态工厂方法。</p>
<ul>
<li><code>public static &lt;E&gt; RingBuffer&lt;E&gt; createMultiProducer(EventFactory&lt;E&gt; factory, int bufferSize, WaitStrategy waitStrategy)</code></li>
<li><code>public static &lt;E&gt; RingBuffer&lt;E&gt; createSingleProducer(EventFactory&lt;E&gt; factory, int bufferSize, WaitStrategy waitStrategy)</code></li>
</ul>
<p>静态工厂方法的第一个参数<code>EventFactory&lt;E&gt; factory</code>用于初始化<code>private final Object[] entries</code>；第二个参数<code>bufferSize</code>用于指定<code>SingleProducerSequencer</code>或<code>MultiProducerSequencer</code>中sequence的长度，也用于指定<code>private final Object[] entries</code>的长度。但三个参数waitStrategy指定<code>EventProcessor</code>的等待策略。</p>
<p><code>RingBuffer</code>中的<code>public SequenceBarrier newBarrier(Sequence... sequencesToTrack)</code>用于生成<code>SequenceBarrier</code>，合适地组合这些Barrier可以构建特定的Dependency Graphs。</p>
<h2 id="producerbarrier">ProducerBarrier</h2>
<ol style="list-style-type: decimal">
<li>生产者向RingBuffer中发布数据，首先通过<code>long sequence = ringBuffer.next()</code>获取数据环中下一个可以可用实体的序列号，该方法将会调用到<code>SingleProducerSequencer</code>或<code>MultiProducerSequencer</code>中的<code>public long next(int n)</code>方法。</li>
</ol>
<p>对于<code>SingleProducerSequencer</code>不存在竞争，唯一需要考虑的是生产者是否会覆盖未消费的数据，在运行系统之前通过RingBuffer的<code>public void addGatingSequences(Sequence... gatingSequences)</code>方法设置ProducerSequencer需要跟踪的最后一个或几个消费者的sequence，这样就可以防止覆盖未消费的数据。</p>
<p>在<code>SingleProducerSequencer</code>中定义了一个内部类Padding记录下一个可获得的序列号和消费者消费到的序列号。</p>
<p>对于<code>MultiProducerSequencer</code>，除了要防止覆盖未消费的数据，还有解决竞争写的问题，笔者可能会直接使用AtomicLong，而在Disruptor中是用Unsafe实现的，在原理上都是用CAS。 2. 然后通过<code>ringBuffer.get(sequence).setValue(i)</code>获取对应的实体，并且设置好数据。 3. 最后通过<code>ringBuffer.publish(sequence)</code>安全发布数据，所谓安全就是要让发布的数据对所有的线程都是可见的。在<code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>中都是通过调用<code>UNSAFE.putOrderedLong(...)</code>完成安全发布，该方法可以使写操作穿过memory barrier。成功发布数据后还需要根据不同的WaitStrategy执行不同的操作，比如BusySpinWaitStrategy不会做任何事情，而BlockingWaitStrategy将会signalAll。</p>
<h2 id="consumerbarrier">ConsumerBarrier</h2>
<p>对于消费者这边，需要有一个或多个<code>EventProcessor</code>做为消费者，具体的处理逻辑通过实现<code>EventHandler</code>或<code>WorkHandler</code>中的<code>onEvent</code>方法定义，从使用者的角度来说是非常清晰的。</p>
<p>对于<code>BatchEventProcessor</code>和<code>WorkProcessor</code>的构造方法都需要传入一个<code>SequenceBarrier</code>，使得消费者可以跟踪生产者的状态，以及有依赖关系的其它消费者的状态。这里传入的<code>SequenceBarrier</code>是通过<code>RingBuffer</code>中的<code>newBarrier(Sequence... sequencesToTrack)</code>方法生成的<code>ProcessingSequenceBarrier</code>。</p>
<p><code>BatchEventProcessor</code>线程起动后就调用<code>ProcessingSequenceBarrier</code>的<code>public long waitFor(final long sequence)</code>方法等待发布的数据，具体的等待策略又因WaitStrategy而不同，等到有新发布的数据就调用重载的<code>onEvent</code>方法执行客户逻辑。</p>
 -->
	
	</div>
  <a type="button" href="/2013/08/07/disruptor5/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-07-06 </div>
			<div class="article-title"><a href="/2013/07/06/notes-jcip/" >Reading notes: Java Concurrency in Practice</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <h2 id="summary-of-part-i">Summary of Part I</h2>
<ul>
<li><p>It’s the mutable state, stupid.</p></li>
<li><p>Make fileds final unless they need to be mutable.</p></li>
<li><p>Immutable objects are automatically thread-safe.</p></li>
<li><p>Encapsulation makes it practical to manage the complexity.</p></li>
<li><p>Guard each mutable variable with a lock.</p></li>
<li><p>Guard all variables in an invariant with the same lock.</p></li>
<li><p>Hold locks for the duration of compound actions.</p></li>
<li><p>A program that accesses a mutable variable from multiple threads without synchronization is a broken program.</p></li>
<li><p>Don’t rely on clever reasoning about why you don’t need to synchronize.</p></li>
<li><p>Include thread safety in the design process-or explicitly document that your class is not thread-safe.</p></li>
<li><p>Document your synchronization policy.</p></li>
</ul>
<h2 id="summary-of-part-ii">Summary of Part II</h2>
<ul>
<li><p>Structuring applications around the execution of tasks can simplify development and facilitate concurrency. The Executor framework permits you to decouple task submission from execution policy and supports a rich variety of execution policies; whenever you find yourself creating threads to perform tasks, consider using an Executor instead. To maximize the benefit of decomposing an application into tasks, you must identify sensible task boundaries. In some applications, the obvious task boundaries work well, whereas in others some analysis may be required to uncover fine-grained exploitable parallelism.</p></li>
<li><p>End-of-lifecycle issues for tasks, threads, services, and applications can add complexity to their design and implementation. Java does not provide a preemptive mechanism for cancelling activities or terminating threads. Insteds, it provides a cooperative interruption mechanism that can be used to facilitate cancellation, but it is up you to construct protocols for cancellation and use them consistently. Using FutureTask and the Executor framework simplifies building cancellable tasks and services.</p></li>
<li><p>The Executor framework is a powerful and flexible framework for concurrently executing tasks. It offers a number of tuning options, such as policies for creating and tearing down threads, handling queued tasks, and what to do with execuss tasks, and provides several hooks for extending its behavior. As in most powerful frameworks, however, there are combinations of settings that do not work well together; some types of tasks require specific execution policies, and some combinations of tuning parameters may produce strange result.</p></li>
<li><p>GUI frameworks are nearly always implemented as single-threaded subsystems in which all presentation-related code runs as tasks in an event thread. Because there is only a single event thread, long-running tasks can compromise responsiveness and so should be executed in background threads. Helper classes like SwingWorker or the BackgroundTask class built here, which provide support for cancellation, progress indication, and completion indication, can simplify the development of long-running tasks that hava both GUI and non-GUI components.</p></li>
</ul>
<h2 id="summary-of-part-iii">Summary of Part III</h2>
<ul>
<li><p>Liveness failures are a serious problem because there is no way to recover from them short of aborting the application. The most common form of liveness failure is lock-ordering deadlock. Avoiding lock ordering deadlock starts at design time: ensure that when threads acquire multiple locks, they do so in a consistent order. The best way to do this is by using open calls throughout your program. This greatly reduces the number of places where multiple locks are held at once, and makes it more obvious where those places are.</p></li>
<li><p>Because one of the most common reasons to use threads is to exploit multiple processors, in discussing the performance of concurrent applications, we are usually more concerned with throughput or scalability than we are with raw service time. Amdahl’s law tells us that the scalability of an application is driven by the proportion of code that must be executed serially. Since the primary source of serialization in Java programs is the exclusive resource lock, scalability can often be improved by spending less time holding locks, either by reducing lock granularity, reducing the duration for which locks are held, or replacing exclusive locks with nonexclusive or nonblocking alternatives.</p></li>
<li><p>Testing concurrent programs for correctness can be extremely challenging because many of the possible failure modes of concurrent programs are low-probability events that are sensitive to timing, load, and other hard-to-reproduce conditions. Further, the testing infrastructure can introduce additional synchronization or timing constraints that can mask concurrency problems in the code being tested. Testing concurrent programs for performance can be equally challenging; Java programs are more difficult to test than programs written in statically compiled languages like C, because timing measurements can be affected by dynamic compilation, garbage collection, and adaptive optimization. To have the best chance of finding latent bugs before they occur in production, combine traditional testing techniques(being careful to avoid the pitfalls discussed here) with code reviews and automated analysis tools. Each of these techniques finds problems that the others are likely to miss.</p></li>
</ul>
<h2 id="summary-of-part-iv">Summary of Part IV</h2>
<ul>
<li><p>Explicit Locks offer an extended feature set compared to intrinsic locking, including greater flexibility in dealing with lock unavailability and greater control over queueing behavior. But ReentrantLock is not a blanket substitute for synchronized; use it only when you need features that synchronized lacks. Read-write locks allow multiple readers to access a guarded object concurrently, offering the potential for improved scalability when accessing read-mostly data structures.</p></li>
<li><p>If you need to implement a state-dependent class - one whose methods must block if a state-based precondition does not hold - the best strategy is usually to build upon an existing library class such as Semaphore, BlockingQueue, or CountDownLatch, as in ValueLatch on page 187. However, sometimes existing library classes do not provide a sufficient foundation; in these cases, you can build your own synchronizers using intrinsic condition queues, explicit Condition objects, or AbstractQueuedSynchronizer. Intrinsic condition queues are tightly bound to intrinsic locking, since the mechanism for managing state dependence is necessarily tied to the mechanism for ensuring state consistency. Similarly, explicity Conditions are tightly bound to explicit Locks, and offer an extended feature set compared to intrinsic condition queues, including multiple wait sets per lock, intrerruptible or uninterrruptible condition waits, fair or nonfair queuing, and deadline-based waiting.</p></li>
<li><p>The Java Memory Model specifies when the actions of one thread on memory are guaranteed to be visible to another. The specifics invole ensuring that operations are ordered by a partial ordering called happens-before, which is specified at the level of individual memory and synchronization operations. In the absence of sufficient synchronization, some very strange things can happen when threads access shared data. However, the higher-level rules offered in Chapters 2 and 3, such as <span class="citation">@GuardedBy</span> and safe publication, can be used to ensure thread safety without resorting to the low-level details of happens-before.</p></li>
</ul>
 -->
	
	</div>
  <a type="button" href="/2013/07/06/notes-jcip/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-06-23 </div>
			<div class="article-title"><a href="/2013/06/23/disruptor4/" >Disruptor: design overview</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <p>Disruptor是一个MQ，其中的Queue是一个ring buffer。</p>
<p>对于queue来说有三个问题需要关注：</p>
<ol style="list-style-type: decimal">
<li>被交换项的存储</li>
<li>声明下一个交换的sequence，用于协调生产者们</li>
<li>通知新的交换项可获得，用于协调消费者们</li>
</ol>
<ul>
<li>针对1，预先分配固定大小的queue，好处是可以减少GC的影响，更好的利用cache。</li>
<li>针对2，对于单生产者，获取序列号没有竞争的问题；对于多生产者，使用CAS操作来获取序列号。</li>
<li>针对3，对于消费者们来说就没有竞争的问题了。可以按照CPU资源的稀缺度，或者使用信号通知模式，或者使用循环检查模式。</li>
</ul>
<p>可见sequence在并发管理中处于核心地位。</p>
<p>在生产者这边，如果是单生产者没有竞争写的问题；如果是多生产者，可以用CAS解决竞争的问题。写完之后，需要更新一个独立的计数器cursor指明最近一个可获得的消息项，这里只需要使用memory barrier，而不需要CAS操作。</p>
<p>在消费者这边，消费者通过使用memory barrier读cursor来等待新的消息项。消费者也有自己的sequence，生产者可以通过读这个sequence来防止覆盖ring上未处理的消息，消费者们也可以通过各自的sequence来协调消费者们的处理顺序。</p>
<p>对于传统的SEDA，不同的stage之间都需要queue，但是对于Disruptor来说，复杂的依赖图完全可以基于一个ringe buffer来实现，这极大的提高了吞吐量，减少了延迟。对于某些stage处于落后的状态，可以使用batch处理的方式迅速赶上来。</p>
 -->
	
	</div>
  <a type="button" href="/2013/06/23/disruptor4/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-06-22 </div>
			<div class="article-title"><a href="/2013/06/22/disruptor3/" >Disruptor: about queue</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <p>Q：queue这种如此简单的数据结构为什么得到了这么广泛的关注？</p>
<p>A：queue确实是一种很容易理解的数据结构，她受到广泛关注是因为在SEDA和Actors中她扮演者重要的角色，她重要是因为她很容易成为系统性能的瓶颈。为什么呢？因为有很多actor或者thread要并发的对queue进程操作嘛。</p>
<p>Q：SEDA和Actors，我也略知一二，仔细想想这里的queue肯定得加锁或者用CAS，之前你也说到这些对性能影响很大，有什么更好的方法么？</p>
<p>A：有，就像之前说到的——避免写竞争。</p>
<p>Q：说起来容易。。。</p>
<p>A：做起来也不难，Disruptor就做到了。</p>
 -->
	
	</div>
  <a type="button" href="/2013/06/22/disruptor3/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-06-18 </div>
			<div class="article-title"><a href="/2013/06/18/disruptor2/" >Disruptor: about concurrency</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <p>Q：Concurrency有什么难的？</p>
<p>A：既然是Concurrency，那么自然而然就有两个问题——mutual exclusion和visibility of change。要实现互斥就得加lock，不仅逻辑上复杂而且对性能也有很大影响。visibility of change相对容易，只要牺牲一下cache就行。</p>
<p>Q：不过是有个CAS么，这个比lock的性能好多了。</p>
<p>A：CAS的性能是比lock高很多，但是CAS结合Memory Barriers会使程序跟复杂，很难验证程序的正确性。</p>
<p>Q：memory barriers是什么？</p>
<p>A：memory barriers可以很好的解决上面提到的visibility of change。另外现在的CPU为了提高性能，不都是乱序执行的嘛，单线程乱序执行CPU自己就能解决，但是对多线程的共享变量，CPU就会被搞糊涂了，所以就引入了memory barriers用来指明某段代码对内存更新的顺序很关心。对于Java语言来说，明白volatile这个关键字就明白memory barriers了。</p>
<p>Q：既然concurrency这么难，为什么还要使用这个？</p>
<p>A：因为CPU单核性能的提升空间已经很小了，多核化是必然的趋势。而要充分利用多核，还就得利用multithreading。。。仔细想想为什么需要mutal exclusion，不就是因为对共享资源有竞争写嘛，实际上在设计软件的时候，如果能避免这种竞争写的情况，就不要lock了，那就太棒了。对于竞争读，memory barriers就能解决问题，而且性能损失不大，又能解决visibity of change。</p>
 -->
	
	</div>
  <a type="button" href="/2013/06/18/disruptor2/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-06-09 </div>
			<div class="article-title"><a href="/2013/06/09/disruptor1/" >Disruptor: what&#39;s Disruptor</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		
		<!-- <p>Q: 什么是Disruptor？</p>
<p>A: 就是个message queue。</p>
<p>Q: 满大街都是。。。有什么特别的？</p>
<p>A：快！</p>
<p>Q：好吧，来个example呗。</p>
<p>A：去看disruptor的perftest就行了呗。</p>
<p>Q：你也太懒了吧。。。我就想看一下用起来方便否？</p>
<p>A：OK</p>
<p>首先肯定是定义消息类嘛</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lmax.disruptor.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueEvent</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> value)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventFactory&lt;ValueEvent&gt; EVENT_FACTORY = <span class="keyword">new</span> EventFactory&lt;ValueEvent&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ValueEvent <span class="title">newInstance</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个消息的handler呗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lmax.disruptor.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventHandler;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.util.PaddedLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAdditionEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ValueEvent</span>&gt;</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaddedLong value = <span class="keyword">new</span> PaddedLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> localSequence = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">final</span> CountDownLatch latch, <span class="keyword">final</span> <span class="keyword">long</span> expectedCount)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        value.set(<span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        count = expectedCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> ValueEvent event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">        value.set(value.get() + event.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localSequence + <span class="number">1</span> == sequence)</span><br><span class="line">        &#123;</span><br><span class="line">            localSequence = sequence;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.err.println(<span class="string">"Expected: "</span> + (localSequence + <span class="number">1</span>) + <span class="string">"found: "</span> + sequence);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == sequence)</span><br><span class="line">        &#123;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是定义我们的MQ，在我们的Disruptor中称做RingBuffer和SequenceBarrier，只要搞明白这个Barrier就能搞出各种队列类型。</p>
<p>例如最简单的单进单出队列这样定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Disruptor:</span><br><span class="line">==========</span><br><span class="line">             track to prevent wrap</span><br><span class="line">             +------------------+</span><br><span class="line">             |                  |</span><br><span class="line">             |                  v</span><br><span class="line">+----+    +====+    +====+   +-----+</span><br><span class="line">| P1 |---&gt;| RB |&lt;---| SB |   | EP1 |</span><br><span class="line">+----+    +====+    +====+   +-----+</span><br><span class="line">     claim      get    ^        |</span><br><span class="line">                       |        |</span><br><span class="line">                       +--------+</span><br><span class="line">                         waitFor</span><br><span class="line"> </span><br><span class="line">P1  - Publisher <span class="number">1</span></span><br><span class="line">RB  - RingBuffer</span><br><span class="line">SB  - SequenceBarrier</span><br><span class="line">EP1 - EventProcessor <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;ValueEvent&gt; ringBuffer =</span><br><span class="line">    createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, <span class="keyword">new</span> YieldingWaitStrategy());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ValueAdditionEventHandler handler = <span class="keyword">new</span> ValueAdditionEventHandler();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BatchEventProcessor&lt;ValueEvent&gt; batchEventProcessor = <span class="keyword">new</span> BatchEventProcessor&lt;ValueEvent&gt;(ringBuffer, sequenceBarrier, handler);</span><br><span class="line">&#123;</span><br><span class="line">    ringBuffer.addGatingSequences(batchEventProcessor.getSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后模拟发发消息，搞个Executor执行EventProcessor就可以玩一下啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">runDisruptorPass</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;</span><br><span class="line">    handler.reset(latch, expectedCount);</span><br><span class="line">    executor.submit(batchEventProcessor);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RingBuffer&lt;ValueEvent&gt; rb = ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; ITERATIONS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> next = rb.next();</span><br><span class="line">        rb.get(next).setValue(i);</span><br><span class="line">        rb.publish(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="keyword">long</span> opsPerSecond = (ITERATIONS * <span class="number">1000L</span>) / (System.currentTimeMillis() - start);</span><br><span class="line">    waitForEventProcessorSequence(expectedCount);</span><br><span class="line">    batchEventProcessor.halt();</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(expectedResult, handler.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> opsPerSecond;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 -->
	
	</div>
  <a type="button" href="/2013/06/09/disruptor1/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/2/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
          <li class="next disabled"><a>Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2015/11/13/notes-releaseit/" ><i class="fa fa-file-o"></i>Reading Notes - Release It!...</a>
      </li>
    
      <li>
        <a href="/2015/11/03/password-strengths-evaluation-pcfg/" ><i class="fa fa-file-o"></i>Password Strengths Evaluati...</a>
      </li>
    
      <li>
        <a href="/2015/11/01/weekly/" ><i class="fa fa-file-o"></i>Weekly 2015-11-01...</a>
      </li>
    
      <li>
        <a href="/2015/10/25/weekly/" ><i class="fa fa-file-o"></i>Weekly 2015-10-25...</a>
      </li>
    
      <li>
        <a href="/2015/09/22/password-strengths-evaluation-entropy/" ><i class="fa fa-file-o"></i>Password Strengths Evaluati...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/shichaoyuan" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2015 Shichao Yuan
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
   </html>
